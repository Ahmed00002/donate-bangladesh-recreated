const openURL = require('opn');
const path = require('path');
const getInternalIp = require('internal-ip');
const { EventEmitter } = require('events');
const { isCSS } = require('./util/extensions');
const createMiddleware = require('./createMiddleware');
const createServer = require('./createServer');
const createWatcher = require('./createWatcher');
const createBundler = require('./createBundler');
const createSocketServer = require('./websocket/createSocketServer');
const getport = require('getport');
const chalk = require('chalk');

module.exports = createSync;
function createSync (opts = {}) {
  const port = parseInt(opts.port, 10);
  if (!isFinite(port)) throw new Error(`Invalid port: ${port}`);

  let closed = false;
  const logger = opts.logger;
  const emitter = new EventEmitter();
  const isSSL = false;
  const localHostList = [ 'localhost', '127.0.0.1' ];
  const host = localHostList.includes(opts.host) ? undefined : opts.host;

  // We only watch for HTML/CSS/JS since the bundler will handle
  // special paths like GLSL, LESS, etc.
  const watchPaths = [ `**/*.{js,css,html}` ];
  const isWatch = true;
  const watcher = isWatch ? createWatcher(watchPaths, opts) : null;

  const hasBundler = opts.entries.length > 0 && opts.js !== false;
  const bundlerOpts = Object.assign({}, opts, {
    // Turn on watcher
    watch: isWatch,
    // On bundle errors, show in client JS instead of crashing server
    failOnError: false,
    // Run a bundle immediately on start for better user experience
    initialBundle: true,
    // Cache in memory during dev so that reloads are quick & easy
    cacheInMemory: true
  });
  const bundler = hasBundler ? createBundler(bundlerOpts) : null;
  const app = createMiddleware(Object.assign({}, opts, {
    bundlerMiddleware: bundler ? bundler.middleware : null
  }));
  const server = createServer(app, opts);
  const client = opts.mode === 'development' ? createSocketServer(server, opts) : null;

  if (hasBundler) {
    // When a file dependency from the bundler is changed
    bundler.on('invalidate', file => {
      if (client) {
        // When reloading any CSS file in the bundle, we just trigger the output CSS file
        if (isCSS(file) && opts.css) {
          client.reload(opts.css);
        } else {
          client.reload(file);
        }
      }
      emitter.emit(file, true);
    });
    bundler.on('glsl', glsl => {
      if (client) client.updateGLSL(glsl.filename, glsl.code);
    });
  }

  if (watcher) {
    watcher
      .on('change', onFileChange)
      .on('add', onFileAdd)
      .on('unlink', onFileChange);
  }

  // pass client errors along to websockets
  if (hasBundler) {
    let curError;
    bundler.on('bundle-error', ({ error, type }) => {
      curError = error;
      logger.statusError(error.toString(), `${type.toUpperCase()} Error`);
      if (client) {
        const errEvent = { error, type };
        client.error(errEvent, { soft: true });
      }
    });
    bundler.on('bundle-no-error', () => {
      if (curError) {
        logger.clearStatusError();
        if (client) client.error(false);
        curError = null;
      }
    });
  }

  // pass along server errors
  server.once('error', err => emitter.emit('error', err));

  emitter.server = server;
  emitter.webSocketServer = client ? client.webSocketServer : undefined;
  emitter.reload = client ? client.reload : () => {};
  emitter.close = close;

  getport(port, (err, result) => {
    if (err) return emitter.emit('error', err);
    server.listen(result, host || undefined, () => connected());
  });

  return emitter;

  function close () {
    if (closed) return;
    closed = true;
    server.close();
    if (watcher) {
      watcher.removeListener('change', onFileChange);
      watcher.removeListener('add', onFileAdd);
      watcher.removeListener('unlink', onFileChange);
      watcher.close();
    }
    if (hasBundler) bundler.close();
    if (client) client.close();
  }

  function onFileAdd (file) {
    if (!hasBundler || !bundler._onFileAdded(file)) {
      // See if adding the file will resolve a missing dependency
      // in the bundler. If not, treat it as a regular file add.
      // NOTE: Right now this won't work with adding GLSL files, only JS/CSS.
      onFileChange(file);
    }
  }

  function onFileChange (file) {
    file = path.resolve(opts.cwd, file);

    const isBundleDependency = hasBundler ? bundler.isDependency(file) : false;
    if (client && !isBundleDependency) {
      // Reload a file outside the bundler, e.g. `index.html` or `vendor/js/script.js`
      client.reload(file);
    }
    emitter.emit('reload', file, isBundleDependency);
  }

  function connected () {
    const internalIp = getInternalIp.v4.sync();
    const protocol = isSSL ? 'https:' : 'http:';
    let serverHost = server.address().address || '::';
    if (serverHost === '0.0.0.0') {
      serverHost = '::';
    }

    if (serverHost === '::') {
      serverHost = internalIp;
    }

    const isLocalHost = opts.mode === 'development' && localHostList.concat([ internalIp ]).includes(serverHost);
    const hosts = [
      isLocalHost ? 'localhost' : null,
      isLocalHost ? internalIp : serverHost
    ].filter(Boolean);

    const serverPort = server.address().port;

    const urls = hosts.map(host => `${protocol}//${host}:${serverPort}/`);

    const urlText = urls.map(url => chalk.magenta(`    ${url}`)).join('\n');
    logger.bullet(`Development server is running on:\n${urlText}`);
    logger.bullet(`Hit ${chalk.bold('Ctrl-C')} to stop the server`);

    if (bundler) {
      bundler.on('bundle-start', () => {
        logger.status('Bundling');
      });
      bundler.on('bundle-time', (ms) => {
        logger.status(`Bundled in ${ms} ms`);
      });
    }

    emitter.emit('connect', {
      url: urls[0],
      urls,
      port: serverPort,
      host: serverHost,
      protocol
    });

    if (opts.open) {
      openURL(urls[0]);
    }
  }
}
