const path = require('path');
const fs = require('fs');
const SimpleError = require('../util/SimpleError');

module.exports = function (bundler, pluginOpts = {}) {
  const basedir = path.resolve(__dirname, '../../');
  const resolver = bundler._bresolve;

  if (typeof bundler._bresolve !== 'function') {
    throw new Error('ERROR: It looks like somehow Texel is using an unsupported version ' +
        'of browserify, please file a bug report in Texel GitHub Issues:\n    https://github.com/mattdesl/texel/issues');
  }

  const aliases = {
    'texel/util/shader': require.resolve('../../util/shader'),
    'texel/util/_shader_prod': require.resolve('./shader/production.js'),
    'texel/util/_shader_dev': require.resolve('./shader/development.js')
  };

  const redirects = [ 'texel/util/exporter', '@babel/runtime', '@babel/polyfill', 'glslify' ];
  const isDev = pluginOpts.mode !== 'production';

  // Resolve certain modules from here instead of user working dir
  bundler._bresolve = function (id, opts, cb) {
    if (redirects.some(other => id.startsWith(other))) {
      opts = Object.assign({}, opts, { basedir });
    } else if (id in aliases) {
      id = aliases[id];
      opts = Object.assign({}, opts, { basedir });
    }

    // Special resolve for dev tools which are optimized away in bundle mode
    if (id === 'texel/util/exporter') {
      if (isDev) id = './util/exporter/development.js';
      else id = './util/exporter/production.js';
    }

    return resolver.call(bundler, id, opts, (err, result, pkg) => {
      // Improve error messaging since browserify sometimes gives you just a folder,
      // not the actual file it was required by. Could improve further by parsing
      // file and getting real syntax error message.
      if (err) {
        cb(new SimpleError(`Cannot find module '${id}' from '${path.relative(path.dirname(process.cwd()), opts.filename)}'`));
      } else {
        cb(null, result, pkg);
      }
    });
  };

  bundler.on('reset', resetHooks);
  resetHooks();

  bundler.on('transform', (tr, mfile) => {
    tr.on('missing', ev => {
      bundler.emit('missing', Object.assign({ type: 'js' }, ev));
    });
  });

  function resetHooks () {
    // Ensure we pick up missing modules so we can install them for better UX
    const deps = bundler.pipeline.get('deps');
    for (let i = 0; i < deps.length; i++) {
      const dep = deps.get(i);
      dep.on('missing', (id, parent) => {
        bundler.emit('missing', {
          id,
          type: 'js',
          parent: parent.filename
        });
      });
    }
  }
};
