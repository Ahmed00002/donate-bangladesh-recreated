const fs = require('fs');
const path = require('path');
const createPostCSS = require('postcss');
const cleanCSS = require('postcss-clean');
const cssImport = require('postcss-import');
const autoprefixer = require('autoprefixer');

const parseLESS = require('./parseLESS');
const parseSASS = require('./parseSASS');

module.exports = function createCSSParser (opts = {}) {
  const minify = opts.minify;

  const postCSSPlugins = [
    cssImport({ root: opts.cwd }),
    autoprefixer({ browsers: opts.browserslist }),
    minify ? cleanCSS() : undefined
  ].filter(Boolean);

  const postcss = createPostCSS(postCSSPlugins);

  const processors = {
    '.less': parseLESS,
    '.scss': parseSASS,
    '.sass': parseSASS
  };

  return function parseCSS (file, bundler) {
    let chain = readFile(file);

    // Apply optional pre-processors like LESS or SASS
    const ext = path.extname(file).toLowerCase();
    if (ext in processors) {
      const fn = processors[ext];
      chain = chain.then(body => {
        return fn(body, file, Object.assign({}, opts, { bundler }));
      });
    } else if (ext !== '.css') {
      return Promise.reject(new Error(`Invalid file extension provided to CSS parser: ${ext}`));
    }

    // Finally, apply postcss which will further apply autoprefixing and minification
    // This may result in a doubling up of autoprefixer. Should investigate whether this
    // is an issue or not.
    // The alternative is to not run postcss on LESS/SASS but this may produce
    // some unexpected behaviour when a user doesn't set up LESS autoprefixer,
    // or when a user adds a custom postcssrc and it won't get picked up by LESS/SASS.
    return chain.then(code => {
      return postcss.process(code, {
        failOnError: true,
        map: false,
        from: file
      });
    }).then(result => {
      // Emit all inlined @import files so watch task can pick them up
      const dependencies = result.messages.filter(m => m.type === 'dependency');
      dependencies.forEach(dep => {
        bundler.emit('file', dep.file);
      });
      return {
        code: result.css
      };
    });
  };
};

function readFile (file) {
  return new Promise((resolve, reject) => {
    fs.readFile(file, 'utf-8', (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
}

function parseVanillaCSS (file) {
  return readFile(file).then(code => {
    return { code };
  });
}
