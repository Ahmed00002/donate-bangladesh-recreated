const through = require('through2');
const path = require('path');
const { EventEmitter } = require('events');
const concat = require('concat-stream');
const { PassThrough } = require('stream');

const createCSSParser = require('./createCSSParser');
const getOrderedCSSDependencies = require('./getOrderedCSSDependencies');
const { isCSS } = require('../../util/extensions');
const emptyModule = 'module.exports = undefined;';
const noop = () => {};

module.exports = function (opts = {}) {
  const parseCSS = createCSSParser(opts);
  const failOnError = opts.failOnError !== false;
  const depCache = {};

  return function plugin (bundler, pluginOpts = {}) {
    let firstRecord = true;
    bundler.pipeline.get('record').unshift(through.obj(function (chunk, enc, next) {
      if (firstRecord) {
        firstRecord = false;
        // First, cache all CSS source code, and also transform it to plain empty JS module
        // so that other transforms will not try to parse it
        this.push({
          transform: emptyCSSModuleTransform,
          global: undefined
        });
        this.push({
          transform: emptyCSSModuleTransform,
          global: true
        });
        next(null, chunk);
      } else {
        next(null, chunk);
      }
    }));

    bundler.on('reset', resetHooks);
    resetHooks();

    bundler.on('invalidate', file => {
      if (file in depCache) delete depCache[file];
    });

    bundler.bundleCombined = function (cb) {
      if (typeof cb !== 'function') throw new Error('Expected cb for bundleCombined()');
      const stream = bundler.bundle();
      let cssResult = {};
      const onCSS = (result) => {
        cssResult = Object.assign({}, result);
      };
      const removeCSS = () => bundler.removeListener('css', onCSS);

      bundler.once('css', onCSS);
      stream.once('error', err => {
        removeCSS();
        cb(err);
        cb = noop;
      });
      stream.on('error', err => {
        bundler.emit('log-error', err);
      });
      stream.pipe(concat(buf => {
        removeCSS();
        const code = buf.toString();
        cb(null, {
          css: cssResult,
          code
        });
        cb = noop;
      }));
    };

    function resetHooks () {
      const allDeps = [];

      // Handle CSS files in this stage of the pipeline
      bundler.pipeline.get('unbom').push(through.obj((chunk, enc, next) => {
        // parse CSS if necessary
        if (isCSS(chunk.file)) {
          parseCSS(chunk.file, bundler)
            .then(result => {
              next(null, Object.assign({}, chunk, {
                source: emptyModule,
                css: result.code
              }));
            }, err => {
              // If we should crash the build or not based on a CSS error
              if (failOnError) {
                next(new Error(err.toString()));
              } else {
                // A single bundle operation may emit several CSS errors
                // But in this case they will not trigger build failures
                bundler.emit('css-error', err);

                next(null, Object.assign({}, chunk, {
                  source: emptyModule,
                  css: `/* Error in CSS file ${path.relative(opts.cwd, chunk.file)}, see console for details. */`
                }));
              }
            });
        } else {
          next(null, chunk);
        }
      }));

      // Later, we grab references to all the dependencies
      bundler.pipeline.get('emit-deps').push(through.obj((chunk, enc, next) => {
        allDeps.push(chunk);
        next(null, chunk);
      }));

      // Lastly, write out final CSS bundle
      bundler.pipeline.get('wrap').push(through((chunk, enc, next) => next(null, chunk), (next) => {
        // Get a list of CSS dependencies
        const cssDeps = allDeps.filter(dep => dep.css);

        // Small perf boost: we can skip ordering if there is just a single dep
        const ordered = cssDeps.length > 1
          ? getOrderedCSSDependencies(allDeps, depCache)
          : cssDeps;

        // concat CSS into a single style sheet
        const code = ordered.map(d => d.css).filter(Boolean).join('\n');

        // Emit final CSS event after all is written
        bundler.emit('css', { code });
        next(null);
      }));
    }
  };

  function emptyCSSModuleTransform (file, opt) {
    if (!isCSS(file)) return new PassThrough();
    return through((chunk, enc, next) => {
      next(null);
    }, function (next) {
      this.push(emptyModule);
      next();
    });
  }
};
