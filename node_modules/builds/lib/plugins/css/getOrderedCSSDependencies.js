const detective = require('detective');

function fastDetective (item, cache) {
  const useCache = cache != null;
  if (useCache && item.file in cache) {
    return cache[item.file];
  }
  const result = detective(item.source);
  if (useCache) cache[item.file] = result;
  return result;
}

module.exports = function getOrderedCSS (deps, cache = null) {
  const moduleMap = deps.reduce((dict, dep) => {
    dict[dep.id] = Object.assign({}, dep);
    return dict;
  }, {});

  const cssIds = [];
  for (let i = 0; i < deps.length; i++) {
    if (deps[i].css) cssIds.push(deps[i].id);
  }

  const finalCSSOrder = [];
  const filesChecked = [];
  const walk = item => {
    // Avoid circular deps / endless walking
    if (filesChecked.includes(item.file)) return;
    filesChecked.push(item.file);

    const originalDeps = item.deps;
    // Get the proper order of dependencies here
    let itemDeps = Object.keys(originalDeps).map(key => {
      return {
        name: key,
        id: originalDeps[key]
      };
    });

    // If it has dependencies, parse AST to get actual order
    let dependencyOrder = item.dependencyOrder;
    if (!dependencyOrder) {
      // cache it for this module
      dependencyOrder = itemDeps.length > 0 ? fastDetective(item, cache) : [];
      // ensure names are strings, in case we are using bundle-collapser
      dependencyOrder = dependencyOrder.map(n => String(n));
      item.dependencyOrder = dependencyOrder;
    }

    // No dependencies in this module, we can bail early
    if (dependencyOrder.length === 0) return;

    itemDeps.forEach(dep => {
      dep.order = dependencyOrder.indexOf(dep.name);
    });

    // Ignore any deps not matching our require statements
    itemDeps = itemDeps.filter(dep => dep.order >= 0);

    // Sort by order in actual AST
    itemDeps.sort((a, b) => a.order - b.order);

    // Now walk through each of those
    itemDeps.forEach(dep => {
      const other = moduleMap[dep.id];
      if (!other) return;
      if (other.css) {
        // If it's already found, remove it from the stack
        const idx = finalCSSOrder.indexOf(dep.id);
        if (idx !== -1) finalCSSOrder.splice(idx, 1);

        // Push it back on to the end
        finalCSSOrder.push(dep.id);
      } else {
        // Other dep is not a CSS dep, we need to walk it
        walk(other);
      }
    });
  };

  // Now walk entire tree from entry point(s) to determine
  // the correct ordering of CSS dependencies
  const entries = deps.filter(dep => dep.entry).sort((a, b) => a.order - b.order);
  if (entries.length === 0) {
    throw new Error('Could not find an entry dependency');
  }

  // Walk through each entry file
  entries.forEach(entry => {
    walk(Object.assign({}, entry));
  });

  // Return the CSS dependencies
  return finalCSSOrder.map(id => moduleMap[id]);
};
