const fs = require('fs');
const chalk = require('chalk');
const path = require('path');
const mkdirp = require('mkdirp');
const padLeft = require('pad-left');

module.exports = function (opts = {}) {
  const logger = opts.logger;
  const outDir = opts.cwd;

  return (req, res, next) => {
    if (req.method !== 'POST') return next(null);

    switch (req.url) {
      case '/texel-dev/exporter/saveFile': return saveFile(req, res);
      default: return next(null);
    }
  };

  function writeError (res, message, statusCode = 400) {
    res.status(statusCode);
    res.send(message);
  }

  function getFile (req, write) {
    const fileName = resolveFile(req.body);
    const filePath = path.resolve(outDir, fileName);
    const fileDir = path.dirname(filePath);
    const next = () => {
      write({ fileName, filePath, fileDir });
    };
    if (fileDir !== outDir) {
      mkdirp(fileDir, err => {
        if (err) {
          logger.error(err);
          return;
        }
        next();
      });
    } else next();
  }

  function saveFile (req, res) {
    if (!req.body || !req.body.data) {
      return writeError(res, 'No base64 data was provided to saveFile function');
    }

    const data = Buffer.from(req.body.data, req.body.encoding);
    getFile(req, ({ filePath }) => {
      if (/svg/i.test(filePath)) console.log(data.toString())
      fs.writeFile(filePath, data, function (err) {
        if (err) {
          logger.error(err);
          return writeError(res, err.message);
        }

        // TODO: Make this persistent or not?
        logger.status(`Saved ${getSaveType(path.extname(filePath))} to ${chalk.bold(path.relative(outDir, filePath))}`, false, 'green');
        res.status(200);
        res.send({
          file: filePath,
          fileRelative: path.relative(opts.cwd, filePath),
          basename: path.basename(filePath),
          dirname: path.dirname(filePath),
          extname: path.extname(filePath),
          length: data.length
        });
      });
    });
  }

  function resolveFile (body) {
    const output = body.output || '';
    const file = body.file;

    let frame = null;
    let extension;
    if (typeof body.extension === 'string') extension = body.extension;
    else if (file) extension = path.extname(file);

    if (typeof body.frame === 'number') {
      let totalFrames;
      if (typeof body.totalFrames === 'number') {
        totalFrames = body.totalFrames;
      } else {
        totalFrames = Math.max(1000, body.frame);
      }
      frame = padLeft(String(body.frame), String(totalFrames).length, '0');
    }

    const formattedFile = formatFile(output, file, extension, frame);
    if (frame != null) {
      if (file) return formattedFile;
      return path.join(output, `${frame}${extension}`);
    } else {
      if (file) return formattedFile;
      // TODO: Could improve situations with multiple simultaneous saves (within same 1 second)
      // by adding a number to make each save more unique. Or, in docs just encourage users to use 'frame'
      // option for that sort of accuracy.
      else return path.join(output, defaultFile(extension));
    }
  }

  function formatFile (output = '', file = '', extension = '', frame = 0) {
    return path.join(output, file.replace(/%d/, frame).replace(/%s/, extension));
  }

  function getSaveType (ext) {
    let type = 'File';
    if (/\.(jpe?g|png|webp)/i.test(ext)) type = 'Image';
    else if (/\.svg/i.test(ext)) type = 'SVG';
    return type;
  }

  function defaultFile (ext) {
    const type = getSaveType(ext);
    const str = `${type} - ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}${ext}`;
    return str.replace(/\//g, '-').replace(/:/g, '.');
  }
};
