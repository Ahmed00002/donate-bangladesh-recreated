const WebSocket = require('ws');
const WebSocketServer = WebSocket.Server;
const stripAnsi = require('strip-ansi');
const path = require('path');
const fs = require('fs');
const mkdirp = require('mkdirp');

module.exports = function (server, opts) {
  opts = opts || {};

  // get a list of static folders to use as base dirs
  let cwd = opts.cwd;
  let staticDirs = [ opts.dir ];

  let currentError = null;
  const clientsInBundleError = [];
  const liveShaderReload = opts.liveShader !== false;

  let closed = false;
  const wss = new WebSocketServer({
    server: server
  });

  wss.on('connection', client => {
    // When page loads, send a message just to that client about
    // current error state
    // Since this is an initial connection, we can skip the message
    // if there is no current error.
    if (currentError) {
      clientsInBundleError.push(client);
      sendErrorState(client);
    }

    client.on('message', data => {
      try {
        const json = JSON.parse(data);
        if (json.event) {
          if (json.event === 'write-default-html') writeDefaultHTML();
        }
      } catch (err) {
        console.error('Could not parse JSON data from WebSocket client:');
        console.error(err);
      }
    });
  });

  return {
    webSocketServer: wss,
    updateGLSL,
    reload,
    error,
    close: function () {
      if (closed) return;
      wss.close();
      closed = true;
    }
  };

  function writeDefaultHTML () {
    const htmlDir = opts.cwd === opts.dir ? opts.cwd : path.resolve(opts.cwd, opts.dir);
    const htmlFile = path.resolve(htmlDir, 'index.html');
    const done = (err) => {
      const result = { event: 'write-default-html' };
      if (err) result.error = err.message;
      else reload(htmlFile);
      sendMessage(result);
    };
    if (!fs.existsSync(htmlFile)) {
      mkdirp(htmlDir, (err) => {
        if (err) return done(err);
        fs.writeFile(htmlFile, opts.defaultHTML, done);
      });
    } else {
      done(new Error('File exists'));
    }
  }

  function error (ev, settings = {}) {
    if (closed) return;
    currentError = ev;

    // For any clients 'stuck' in a bundle error state,
    // we need to get them out by reloading them.
    if (!currentError) {
      clientsInBundleError.forEach(client => {
        sendReloadState({}, client);
      });
      // Filter out ones we sent reload events, they will get on connection
      // clients = clients.filter(c => !clientsInBundleError.includes(c));
      clientsInBundleError.length = 0;
    }

    // Broadcast error state to all clients
    if (!currentError || !settings.soft || ev.type !== 'js') {
      sendErrorState();
    }
  }

  function sendErrorState (client) {
    if (!currentError) {
      sendMessage({ event: 'error-resolved' }, client);
    } else {
      sendMessage({
        event: 'error',
        type: currentError.type,
        message: stripAnsi(currentError.error.toString())
      }, client);
    }
  }

  function sendReloadState (data, client) {
    sendMessage(Object.assign({ event: 'reload', isLiveShader: liveShaderReload }, data), client);
  }

  function reload (file) {
    if (closed) return;

    let url, ext;
    if (file && typeof file === 'string') {
      if (file !== opts.css && file !== opts.js) {
        // absolute file path
        file = path.isAbsolute(file) ? path.normalize(file) : path.resolve(cwd, file);

        // make it relative, removing the static folder parts
        for (let i = 0; i < staticDirs.length; i++) {
          const dir = staticDirs[i];
          url = path.relative(dir, file);
          // if the path doesn't starts with "../", then
          // it should be relative to this folder
          if (!/^(\.\.[/\\]|[/\\])/.test(url)) break;
        }

        // turn it into a URL
        url = url.replace(/\\/g, '/');

        // ensure it starts at root of app
        if (url.charAt(0) !== '/') url = '/' + url;
      } else {
        url = file;
      }
    }

    if (file) ext = path.extname(file);

    // Broadcast to all clients a reload
    sendReloadState({ ext, file, url });
  }

  function updateGLSL (file, code) {
    sendMessage({ event: 'glsl', file, code });
  }

  function sendMessage (data, targetClient) {
    if (closed) return;
    data = JSON.stringify(data);
    try {
      const send = (client, data) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(data, {
            binary: false
          });
        }
      };
      if (targetClient) {
        const targets = [].concat(targetClient).filter(Boolean);
        targets.forEach(target => send(target, data));
      } else {
        wss.clients.forEach(client => send(client, data));
      }
    } catch (err) {
      console.error('Error sending LiveReload event to client:');
      console.error(err);
    }
  }
};
