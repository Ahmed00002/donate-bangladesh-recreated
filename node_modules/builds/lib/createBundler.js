const browserify = require('browserify');
const fs = require('fs');
const chalk = require('chalk');
const fromArgs = require('browserify/bin/args');
const stripAnsi = require('strip-ansi');
const path = require('path');
const through = require('through2');
const getBundlerTransforms = require('./transforms/getBundlerTransforms');
const bundleCollapserPlugin = require('bundle-collapser/plugin');
const createCSSPlugin = require('./plugins/css');
const resolve = require('./plugins/resolve');
const URL = require('url');
const extensions = require('./util/extensions');
const { EventEmitter } = require('events');
const createWatcher = require('./createWatcher');
const uglify = require('uglify-es');
const babelPolyfillEntry = require.resolve('@babel/polyfill');

class Node {
  constructor (file) {
    this.file = file;
    this.edges = [];
  }

  addEdge (other) {
    if (!this.edges.includes(other)) this.edges.push(other);
  }

  removeEdge (other) {
    const idx = this.edges.indexOf(other);
    if (idx >= 0) this.edges.splice(idx, 1);
  }

  disconnect () {
    this.edges.forEach(edge => {
      edge.removeEdge(this);
    });
  }
}

module.exports = function (opts = {}) {
  const jsUrl = opts.js;
  const cssUrl = opts.css;
  const logger = opts.logger;

  let closed = false;
  const watch = opts.watch;
  let transformDepNodes = [];
  const watchedFiles = [];
  let dependencies = [];
  const missingModules = [];

  const {
    bundler,
    cache,
    packageCache
  } = createBrowserify();

  const watcher = watch ? createWatcher([], opts) : null;
  if (watcher) {
    watcher.on('error', bundler.emit.bind(bundler, 'error'));
    watcher.on('unlink', file => {
      file = path.isAbsolute(file) ? file : path.resolve(opts.cwd, file);
      // Could trigger a rebundle here, but really we should invalidate
      // all sources that depended on the removed file. This is not simple
      // so instead we will leave it in cache until the next reload, which
      // seems OK for UX.
      // if (watchedFiles.includes(file)) invalidate(file);
    });
    watcher.on('change', file => {
      file = path.isAbsolute(file) ? file : path.resolve(opts.cwd, file);
      if (watchedFiles.includes(file)) invalidate(file);
    });
  }

  const failOnError = opts.failOnError !== false;
  const initialBundle = Boolean(opts.initialBundle);
  const cacheInMemory = Boolean(opts.cacheInMemory);

  const emitter = new EventEmitter();
  let lastBundleResult;
  if (initialBundle) {
    // Wait a tick to let events go in first
    process.nextTick(() => {
      bundleAndCache();
    });
  }

  const sendMessage = (message, res, type) => {
    res.set('Content-Type', type + '; charset=utf-8');
    res.set('Content-Length', Buffer.isBuffer(message)
      ? message.length
      : Buffer.byteLength(message));
    res.status(200);
    res.end(message, 'utf8');
  };

  const sendError = (err, res, type) => {
    if (!opts.quiet) {
      console.error(err);
    }
    const msg = '/* Error in bundle step, see terminal console for details. */';
    sendMessage(msg, res, type);
  };

  Object.assign(emitter, {
    isDependency: (file) => dependencies.includes(file),
    bundle,
    _onFileAdded,
    close,
    middleware: (req, res, next) => {
      const pathname = URL.parse(req.url).pathname;
      if (pathname === jsUrl) {
        const type = 'application/javascript';
        getCachedBundle()
          .then(result => sendMessage(result.code, res, type))
          .catch(err => sendError(err, res, type));
      } else if (pathname === cssUrl) {
        const type = 'text/css';
        getCachedBundle()
          .then(result => sendMessage(result.css.code, res, type))
          .catch(err => sendError(err, res, type));
      } else {
        next(null);
      }
    }
  });

  // We wish to keep the API very narrow and remove users
  // manually hacking around with the browserify object.
  // But there are some events that we should pass along
  const carryEvents = [ 'file', 'dep' ];
  carryEvents.forEach(ev => {
    bundler.on(ev, emitter.emit.bind(emitter, ev));
  });
  return emitter;

  function _onFileAdded (file) {
    file = path.isAbsolute(file) ? file : path.resolve(opts.cwd, file);

    // If it's one of our missing modules, invalidate parent
    let changed = false;
    for (let i = 0; i < missingModules.length; i++) {
      const missing = missingModules[i];
      // If the missing module is not a relative or absolute path, skip it
      if (!/^[./\\]/.test(missing.id)) continue;
      // If the parent isn't being watched
      if (!watchedFiles.includes(missing.parent)) continue;

      let missingPath = path.isAbsolute(missing.id) ? missing.id : path.resolve(path.dirname(missing.parent), missing.id);
      if (missingPath === file) {
        changed = true;
        invalidate(missing.parent);
        break;
      }
    }

    if (!changed && watchedFiles.includes(file)) {
      changed = true;
      invalidate(file);
    }
    return changed;
  }

  function getCachedBundle () {
    if (cacheInMemory && lastBundleResult) {
      return lastBundleResult;
    }
    return bundleAndCache();
  }

  function bundleAndCache () {
    const result = bundle();
    if (cacheInMemory) lastBundleResult = result;
    return result;
  }

  function bundle () {
    return new Promise((resolve, reject) => {
      emitter.emit('bundle-start');
      let time = Date.now();

      const missingBundledModules = [];
      const handleMissing = (ev) => {
        missingBundledModules.push(ev);
      };
      bundler.on('missing', handleMissing);

      let currentError = false;
      const onCSSError = err => {
        currentError = true;
        emitter.emit('bundle-error', { error: err, type: 'css' });
      };
      const done = (result) => {
        if (!currentError) {
          emitter.emit('bundle-no-error');

          const ms = Date.now() - time;
          emitter.emit('bundle-time', ms);
        }
        resolve(result);
      };
      bundler.on('css-error', onCSSError);

      // bundleCombined function gets injected via css plugin
      bundler.bundleCombined((err, result) => {
        // done with this listener, remove it to ensure no memory leak
        bundler.removeListener('css-error', onCSSError);
        bundler.removeListener('missing', handleMissing);

        if (!err && opts.minify) {
          try {
            var min = uglify.minify(result.code.toString(), {
              mangle: {
                toplevel: true
              },
              warnings: true,
              compress: {
                dead_code: true,
                evaluate: true
              }
            });
            if (min.error) {
              err = min.error;
            } else {
              result = Object.assign({}, result, { code: min.code });
            }
          } catch (e) {
            err = e;
          }
        }

        if (missingBundledModules.length > 0) {
          const missing = missingBundledModules.filter((item, index, array) => {
            return array.findIndex(m => m.id === item.id) === index;
          });
          let msg;
          if (missing.length === 1) {
            msg = `Cannot find module '${missing[0].id}' from ${missing[0].parent}`;
          } else {
            const multiples = missing.map(m => `  '${m.id}' from ${m.parent}`).join('\n');
            msg = `Cannot find the following modules:\n${multiples}`;
          }
          err = new Error(msg);
          err.code = 'MODULE_NOT_FOUND';
          err.errorType = missing.every(m => m.type === 'glsl') ? 'glsl' : 'js';
          err.missingModules = missing;
          err.allMissingModules = missingBundledModules;
        }

        if (err) {
          if (failOnError) {
            return reject(err);
          } else {
            currentError = true;
            emitter.emit('bundle-error', { error: err, type: err.errorType || 'js' });
            return resolve({
              code: getErrorSource(err),
              css: { code: '/* Error in JavaScript build; CSS discarded. */' }
            });
          }
        }

        done(result);
      });
    });
  }

  function getErrorSource (err) {
    const msg = stripAnsi(err.message);
    return `!(function () {console.error(${JSON.stringify(msg)});})();`;
  }

  function createBrowserify () {
    const cache = {};
    const packageCache = {};
    const css = createCSSPlugin(opts);
    const collapser = opts.minify ? bundleCollapserPlugin : null;

    let browserifyOpts = Object.assign({}, opts.browserify);
    const defaultPlugins = [ [ resolve, opts ], css, collapser ].filter(Boolean);
    const defaultTransforms = getBundlerTransforms(opts);
    browserifyOpts.plugin = defaultPlugins.concat(browserifyOpts.plugin || []);
    browserifyOpts.transform = defaultTransforms.concat(browserifyOpts.transform || []);

    const bOpts = Object.assign({}, browserifyOpts, {
      cache,
      ignoreMissing: true,
      node: opts.node,
      extensions: extensions.list,
      basedir: opts.cwd,
      packageCache,
      debug: opts.debug,
      entries: []
    });

    const args = opts.browserifyArgs;
    let bundler;
    if (args && Array.isArray(args)) {
      // CLI args for browserify
      bundler = fromArgs(args, bOpts);
    } else {
      // assume JS only options
      bundler = browserify(bOpts);
    }

    // add polyfill if necessary
    if (opts.polyfill && !opts.optimize) {
      bundler.add(babelPolyfillEntry);
    }

    // sketching mode
    if (opts.sketch && typeof opts.sketch === 'string') {
      bundler.add(opts.sketch);
    }

    // entries
    opts.entries.forEach(entry => bundler.add(entry));

    // Check for collisions to improve UX and user errors
    const staticJSBundle = path.join(opts.dir, opts.js);
    const collision = opts.entries.find(entry => entry === staticJSBundle);
    if (collision) {
      logger.warn(`The input file, ${chalk.bold(path.relative(opts.cwd, collision))}, is the same as the --js output file. This may cause problems when you plan to bundle your site. Instead, you should rename your entry file, or choose a different --js output file. Examples:

  texel start index.js --js /bundle.js
  texel start bundle.js --js /index.js`);
    }

    bundler.on('reset', () => {
      dependencies.length = 0;
      missingModules.length = 0;
      collect();
    });
    bundler.on('dep', dep => {
      if (!dependencies.includes(dep.file)) dependencies.push(dep.file);
      watchFile(dep.file);
    });
    bundler.on('file', (file) => {
      if (!dependencies.includes(file)) dependencies.push(file);
      watchFile(file);
    });
    bundler.on('transform', (tr, mfile) => {
      tr.on('glsl', glsl => {
        emitter.emit('glsl', glsl);
      });
      tr.on('file', dep => {
        if (!dependencies.includes(dep)) dependencies.push(dep);
        watchFile(mfile, dep);
      });
    });
    bundler.on('package', (pkg) => {
      var file = path.join(pkg.__dirname, 'package.json');
      if (!dependencies.includes(file)) dependencies.push(file);
      watchFile(file);
      packageCache[file] = pkg;
    });

    bundler.on('missing', ev => missingModules.push(ev));
    collect();
    return { css, bundler, cache, packageCache };

    function collect () {
      bundler.pipeline.get('deps').push(through.obj(function (row, enc, next) {
        var file = row.expose ? bundler._expose[row.id] : row.file;
        // If a module is missing, don't cache it's parent file.
        if (!row.source || missingModules.some(m => m.parent === file)) {
          delete cache[file];
        } else if (row.source) {
          cache[file] = {
            source: row.source,
            deps: Object.assign({}, row.deps)
          };
        }
        this.push(row);
        next();
      }));
    }
  }

  function getOrCreateNode (file) {
    let node = transformDepNodes.find(n => n.file === file);
    if (!node) { // got a new parent node
      node = new Node(file);
      transformDepNodes.push(node);
    }
    return node;
  }

  function watchFile (file, dep) {
    if (!watch || closed) return;
    dep = dep || file;

    // If this is a child of a parent file
    if (file !== dep) {
      const parentNode = getOrCreateNode(file);
      const childNode = getOrCreateNode(dep);
      parentNode.addEdge(childNode);
      childNode.addEdge(parentNode);
    }

    // Start listening to this file
    if (!watchedFiles.includes(dep)) {
      watchedFiles.push(dep);
      if (watcher) watcher.add(dep);
    }
  }

  function invalidateFromCache (file) {
    delete cache[file];
    delete packageCache[file];
    const idx = watchedFiles.indexOf(file);
    if (idx >= 0) {
      watchedFiles.splice(idx, 1);
      if (watcher) watcher.unwatch(file);
    }
  }

  function invalidate (file) {
    if (closed) return;

    // Get any associated files
    const node = transformDepNodes.find(n => n.file === file);
    if (node) {
      const nodes = getLinkedNodes(node);
      nodes.forEach(node => {
        invalidateFromCache(node.file);
        node.disconnect();
      });

      // Filter out the disconnected nodes
      transformDepNodes = transformDepNodes.filter(n => !nodes.includes(n));
    }

    // Invalidate this file from cache
    invalidateFromCache(file);

    // trigger a re-build immediately
    bundler.emit('invalidate', file);
    emitter.emit('invalidate', file);
    bundleAndCache();
  }

  function getLinkedNodes (node, resolved = [], seen = []) {
    if (!seen.includes(node)) { // new node
      seen.push(node);
      node.edges.forEach(edge => { // walk its edges
        if (!resolved.includes(edge) && !seen.includes(edge)) {
          // edge not yet resolved and not yet seen, walk it
          getLinkedNodes(edge, resolved, seen);
        }
      });
      resolved.push(node);
    }
    return resolved;
  }

  function close () {
    if (closed) return;
    closed = true;
    lastBundleResult = null;
    if (watcher) watcher.close();
  }
};
