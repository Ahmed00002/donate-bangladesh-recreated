const express = require('express');
const compress = require('compression');
const serveStatic = require('serve-static');
const pushState = require('connect-pushstate');
const errorHandler = require('errorhandler');
const cors = require('cors');
const path = require('path');
const logger = require('morgan');
const createSocketMiddleware = require('./websocket/createSocketMiddleware');
const bodyParser = require('body-parser');
const fs = require('fs');
const URL = require('url');
const { format } = require('util');
const escapeHTML = require('escape-html');

module.exports = createMiddleware;
function createMiddleware (opts = {}) {
  const app = express();
  const mode = opts.mode || 'development';

  // Enable CORS if necessary
  const corsOpts = opts.cors;
  if (corsOpts) {
    app.use(cors());
  }

  // Compress in production or if desired
  if (opts.compress === true) {
    app.use(compress());
  }

  // Handle SPA pushstate style
  if (opts.pushstate) {
    app.use(pushState());
  }

  // Logging
  if (opts.log) {
    const defaultFormat = mode === 'production' ? 'common' : 'dev';
    const logFormat = typeof opts.log === 'string' ? opts.log : defaultFormat;
    app.use(logger(logFormat));
  }

  // Client/livereload etc
  if (mode !== 'production') {
    // Maybe canvsa exporter should use WebSockets to remove
    // the need for this?
    app.use(bodyParser.json({
      limit: '2gb'
    }));
    app.use(createSocketMiddleware(opts));
  }

  // If necessary, a bundler middleware layer
  if (opts.bundlerMiddleware) {
    app.use(opts.bundlerMiddleware);
  }

  // Send static assets
  const staticOpts = mode !== 'production' ? {
    setHeaders: (res, path) => {
      if (serveStatic.mime.lookup(path) === 'application/javascript') {
        res.setHeader('Cache-Control', 'public, max-age=0');
      }
    },
    cacheControl: false
  } : {};
  app.use(serveStatic(opts.dir, staticOpts));

  // Default HTML handler
  app.use((req, res, next) => {
    const pathname = URL.parse(req.url).pathname;
    if (pathname === '/' || /\/index.html?/i.test(pathname)) {
      res.setHeader('Content-Type', 'text/html');
      res.status(200).end(opts.defaultHTML);
    } else {
      next(null);
    }
  });

  // If no favicon is served via static files, then return empty file to avoid
  // 404 errors spamming development tools
  const faviconRegex = /\/favicon\.(jpe?g|png|ico|gif)$/i;
  app.use((req, res, next) => {
    if (faviconRegex.test(req.url)) {
      var maxAge = 60 * 60 * 24; // 1 day
      res.set({
        'Cache-Control': 'public, max-age=' + Math.floor(maxAge / 1000),
        'Content-Type': 'image/x-icon'
      });
      res.status(200);
      res.end();
    } else {
      next(null);
    }
  });

  // Handle welcome page
  if (opts.welcome) {
    app.use((req, res, next) => {
      const url = URL.parse(req.url).pathname;
      if (url === '' || url === '/' || /\/.*(html|htm)?^/i.test(url)) {
        const data = fs.readFileSync(path.resolve(__dirname, 'frontend/welcome.html'), 'utf-8');
        const str = format(data, JSON.stringify(escapeHTML(opts.defaultHTML)));
        res.status(200).send(str);
      } else {
        next(null);
      }
    });
  }

  // 404 handler
  app.use((req, res, next) => {
    if (mode !== 'production') {
      const frontendErrorHTML = fs.readFileSync(path.resolve(__dirname, 'frontend/error.html'), 'utf-8');
      res.status(404).send(format(frontendErrorHTML, '404', `File not found: <strong>${encodeURI(req.url)}</strong>`));
    } else {
      res.sendStatus(404);
    }
  });

  // error handling middleware should be loaded after the loading the routes
  if (mode !== 'production') {
    app.use(errorHandler());
  }

  return app;
}
