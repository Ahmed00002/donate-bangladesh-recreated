const resolveGLSL = require('../../util/resolve-glsl');
const compileGlslify = require('../../util/compile-glslify');
const { requireIds } = require('../../transforms/createShaderImport');
const getModuleNotFound = require('../../util/get-module-not-found');

const path = require('path');
const fs = require('fs');

/*
STEP 1
  import { loadShader } from 'texel/util/shader';
  import { loadShader, createShader } from 'texel/util/shader';
  const shader = loadShader('./foo.glsl');
  // in dev:
  // const shader = require('texel/util/_shader_dev').loadShader('void main(){}', '/path/to/foo.glsl');
  // in prod: (different path, remove filename for security)
  // const shader = require('texel/util/_shader_prod').loadShader('void main(){}');
*/

const moduleName = 'texel/util/shader';
const allModuleNames = [ moduleName, requireIds.production, requireIds.development ];
const SHADER_LOAD_METHOD = 'loadShader';

module.exports = function ({ template, types: t }) {
  let scopes = {};

  return {
    pre () {
      scopes = {};
    },
    visitor: {
      Program: {
        enter (nodePath, params) {
          if (!params.filename) throw new Error('filename required for babel-shader-import plugin');
          scopes[params.filename] = [];

          // Bail early when there is no shader import
          if (!/texel\/util\/(shader|_shader_dev|_shader_prod)/.test(params.file.code)) {
            return;
          }

          // This has to run before preset-env and similar plugins...
          // Need to force a full traversal.
          nodePath.traverse({
            ImportDeclaration: {
              enter: node => inlineImports(node, params)
            },
            CallExpression: {
              enter: node => inlineRequires(node, params),
              exit: node => gatherRequireScopes(node, params)
            }
          });

          const curScopes = scopes[params.filename] || [];
          delete scopes[params.filename];
          curScopes.forEach(scope => {
            const binding = scope.binding;
            if (!binding) return;
            const references = binding.referencePaths;
            references.forEach(ref => {
              if (t.isCallExpression(ref.container)) {
                modifyArguments(ref.parentPath, params, scope.importedName);
              } else if (t.isMemberExpression(ref.container)) {
                modifyArguments(ref.parentPath.parentPath, params, scope.importedName);
              }
            });
          });
        }
      }
    }
  };

  function gatherRequireScopes (nodePath, params) {
    if (!params.filename) throw new Error('filename required for babel-shader-import plugin');
    if (!isShaderRequire(nodePath)) return;
    const parent = nodePath.parentPath;
    const curScopes = scopes[params.filename];

    if (!parent) return;
    const varDeclaration = parent.parent;
    if (!varDeclaration) {
      return;
    }

    if (t.isVariableDeclaration(varDeclaration)) {
      // e.g. const shaderLib = require('texel/util/shader');
      varDeclaration.declarations.forEach(decl => {
        if (t.isIdentifier(decl.id)) {
          curScopes.push({
            varName: decl.id.name,
            binding: nodePath.scope.getBinding(decl.id.name)
          });
          if (!nodePath.scope.getBinding(decl.id.name)) {
            console.error('WTF', decl.id.name);
          }
        } else if (t.isObjectPattern(decl.id)) {
          decl.id.properties.forEach(prop => {
            if (!t.isObjectProperty(prop)) return;
            if (!t.isIdentifier(prop.key) || !t.isIdentifier(prop.value)) return;
            const varName = prop.value.name;
            const importedName = prop.key.name;
            if (importedName === SHADER_LOAD_METHOD) {
              curScopes.push({ varName, importedName, binding: nodePath.scope.getBinding(varName) });
            }
          });
        }
      });
    } else if (t.isVariableDeclarator(varDeclaration) &&
        t.isIdentifier(varDeclaration.id) &&
        t.isMemberExpression(varDeclaration.init) &&
        t.isIdentifier(varDeclaration.init.property)) {
      // e.g. const loadShader = require('texel/util/shader').loadShader;
      const varName = varDeclaration.id.name;
      const importedName = varDeclaration.init.property.name;
      if (importedName === SHADER_LOAD_METHOD) {
        curScopes.push({
          varName,
          importedName,
          binding: nodePath.scope.getBinding(varName)
        });
      }
    } else if (t.isCallExpression(varDeclaration) &&
        t.isMemberExpression(varDeclaration.callee) &&
        t.isCallExpression(parent.parentPath)) {
      const varParent = parent.parentPath.parentPath;
      if (t.isExpressionStatement(varParent)) {
        // Inline statement without declaration, like so:
        // require('foobar').load();
        const callee = varParent.node.expression.callee;
        if (t.isMemberExpression(callee)) {
          modifyArguments(varParent.get('expression'), params);
        }
      } else if (t.isVariableDeclarator(varParent) &&
          t.isCallExpression(varParent.node.init) &&
          t.isIdentifier(varParent.node.init.callee.property)) {
        // Inline statement with declaration, like so:
        // const a = require('foobar').blah();
        modifyArguments(varParent.get('init'), params);
      }
    }
  }

  function modifyArguments (nodePath, params, methodName) {
    const callee = nodePath.get('callee');

    if (!methodName) {
      if (t.isMemberExpression(callee)) {
        methodName = callee.node.property.name;
      } else if (t.isIdentifier(callee)) {
        methodName = callee.name;
      } else {
        return;
      }
    }

    if (methodName !== SHADER_LOAD_METHOD) return;

    const args = nodePath.get('arguments');

    if (t.isBooleanLiteral(args[0])) {
      // If we have a boolean literal as first argument,
      // do not modify a second time.

      // Here we also strip the file name to avoid leaking any
      // user info.
      const { opts } = params || {};
      if (t.isStringLiteral(args[2]) && opts.mode === 'production') {
        args[2].replaceWith(t.stringLiteral(''));
      }

      return;
    }

    const evaluatedArgs = args.map(arg => arg.evaluate());
    if (evaluatedArgs.some(a => !a.confident)) {
      throw new Error(`When calling ${methodName}, you must pass plain strings that can be statically evaluated at build-time.`);
    }

    const argVals = evaluatedArgs.map(a => a.value);
    const id = argVals[0];
    if (!id) throw new Error(`First parameter given to ${methodName} is empty`);

    const { opts } = params || {};
    const basedir = opts.cwd || process.cwd();
    const filename = params.filename;
    const fileDir = filename ? path.dirname(filename) : basedir;

    // resolve GLSL file as we can
    const glslFile = resolveGLSL.sync(id, { basedir: fileDir });

    // emit new dependency
    emitFile(params, glslFile);

    let result = { code: '', dependencies: [] };
    try {
      result = compileShader(glslFile, argVals[1] || {}, {
        cwd: basedir
      });
    } catch (err) {
      const id = getModuleNotFound(err);
      if (id && params && params.file && params.file.metadata) {
        if (!('missingModules' in params.file.metadata)) {
          params.file.metadata.missingModules = [];
        }
        params.file.metadata.missingModules.push({ id, parent: glslFile, type: 'glsl' });
      }
    }

    const code = result.code;

    // include any glslified files as well
    result.dependencies.forEach(dep => {
      emitFile(params, dep);
    });

    const newArgs = args.map(a => a.node);
    // To avoid re-modifying this function on subsequent bundles,
    // we mark the first argument as 'true' (i.e. already compiled).
    // Another way might be to change function names, but that would
    // involve a lot more dramatic source changes w.r.t. scoping.
    newArgs[0] = t.booleanLiteral(true);

    // insert the GLSL source code as second argument
    newArgs.splice(1, 0, t.stringLiteral(code));

    // in production, strip out file path as it may leak some user information
    const fileForMode = opts.mode !== 'production' ? glslFile : '';
    newArgs.splice(2, 0, t.stringLiteral(fileForMode));

    // include shader details in metadata as well
    if (params && params.file && params.file.metadata) {
      if (!('shaders' in params.file.metadata)) {
        params.file.metadata.shaders = [];
      }
      const existing = params.file.metadata.shaders.find(s => s.filename === glslFile);
      if (existing) {
        existing.source = code;
      } else {
        params.file.metadata.shaders.push({ filename: glslFile, code });
      }
    }

    // replace arguments
    nodePath.node.arguments = newArgs;
  }

  function compileShader (id, shaderOpts = {}, pluginOpts = {}) {
    if (shaderOpts.glslify !== false) {
      return compileGlslify(id, pluginOpts);
    } else {
      return {
        code: fs.readFileSync(id, 'utf-8'),
        dependencies: []
      };
    }
  }

  function isShaderRequire (nodePath) {
    const callee = nodePath.get('callee');
    if (callee.isIdentifier() && callee.equals('name', 'require')) {
      const arg = nodePath.get('arguments')[0];
      if (arg && arg.isStringLiteral() && allModuleNames.includes(arg.node.value)) {
        return true;
      }
    }
    return false;
  }

  function getShaderImports (nodePath, params) {
    const sourcePath = nodePath.get('source');
    if (!sourcePath || !sourcePath.node) return null;
    const importedModule = sourcePath.node.value;
    if (!allModuleNames.includes(importedModule)) return null;

    const specifiers = nodePath.get('specifiers');
    if (!specifiers) return null;
    return specifiers;
  }

  function getNewModuleName (params) {
    const { opts } = params || {};
    return opts.mode !== 'production' ? requireIds.development : requireIds.production;
  }

  function inlineImports (nodePath, params) {
    const specifiers = getShaderImports(nodePath, params);
    if (!specifiers) return;

    const newModuleName = getNewModuleName(params);

    if (specifiers.length <= 0) {
      // replace no-var import with require using correct path
      const buildRequire = template(`require(SOURCE);`);
      nodePath.replaceWith(buildRequire({
        SOURCE: t.stringLiteral(newModuleName)
      }));
    } else {
      const hasNamespace = specifiers.some(spec => t.isImportNamespaceSpecifier(spec));
      if (hasNamespace) throw new Error(`You cannot use wildcard * when importing "texel/util/shader".\n\nTry changing it to a named import, such as:\n  import { loadShader } from 'texel/util/shader';\n\nOr, you can import the default object:\n  import lib from 'texel/util/shader';\n`);
      const newNodes = [];
      const specList = specifiers.slice();
      const defSpecIdx = specList.findIndex(s => t.isImportDefaultSpecifier(s));
      // Insert the default specifier
      if (defSpecIdx >= 0) {
        const defSpec = specList[defSpecIdx];
        specList.splice(defSpecIdx, 1);

        const varName = defSpec.node.local.name;
        const buildRequire = template(`const VAR_NAME = require(SOURCE);`);
        const newNode = buildRequire({
          VAR_NAME: t.identifier(varName),
          SOURCE: t.stringLiteral(newModuleName)
        });
        newNodes.push(newNode);
      }

      // Insert remaining named specifiers
      specList.forEach(spec => {
        const importedName = spec.node.imported.name;
        const varName = spec.node.local.name;
        const buildRequire = template(`const VAR_NAME = require(SOURCE).IMPORTED_NAME;`);
        newNodes.push(buildRequire({
          IMPORTED_NAME: t.identifier(importedName),
          VAR_NAME: t.identifier(varName),
          SOURCE: t.stringLiteral(newModuleName)
        }));
      });

      nodePath.replaceWithMultiple(newNodes);
    }
  }

  function inlineRequires (nodePath, params) {
    if (!isShaderRequire(nodePath)) return;
    const newModuleName = getNewModuleName(params);
    nodePath.node.arguments[0] = t.stringLiteral(newModuleName);
  }

  function emitFile (params, glslFile) {
    if (params && params.file && params.file.metadata) {
      if (!('dependencies' in params.file.metadata)) {
        params.file.metadata.dependencies = [];
      }
      if (!params.file.metadata.dependencies.includes(glslFile)) {
        params.file.metadata.dependencies.push(glslFile);
      }
    }
  }
};
