module.exports = function ({ types: t }) {
  return {
    visitor: {
      MemberExpression: handler
    }
  };

  function handler (nodePath, params) {
    const { opts } = params || {};
    const env = opts.env || {};
    if (!nodePath.node.object || !nodePath.node.property) return;
    if (!nodePath.container || !t.isMemberExpression(nodePath.container)) return;
    if (nodePath.container && nodePath.node.object.name === 'process' && nodePath.node.property.name === 'env') {
      const key = nodePath.container.property.name;
      if (!(key in env)) return;
      const val = env[key];
      const parent = nodePath.parentPath;

      const node = t.valueToNode(val);
      parent.replaceWith(node);

      if (t.isArrayExpression(parent) && t.isMemberExpression(parent.parentPath)) {
        const obj = parent.parentPath.node.object;
        const prop = parent.parentPath.node.property;
        if (t.isNumericLiteral(prop) && prop.value >= 0 && prop.value < obj.elements.length) {
          const result = obj.elements[prop.value];
          parent.parentPath.replaceWith(result);
        }
      } else if (parent.parentPath.isBinaryExpression()) {
        const evaluated = parent.parentPath.evaluate();
        if (evaluated.confident) {
          parent.parentPath.replaceWith(t.valueToNode(evaluated.value));
        }
      }
    }
  }
};
