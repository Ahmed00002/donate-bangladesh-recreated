const utils = require('./plugin-utils');

const staticModules = {
  fs: {
    readFile: () => {},
    readFileSync: () => {}
  },
  path: {
    resolve: () => {},
    join: () => {}
  }
};

module.exports = function ({ types: t }) {
  let scopes = {};
  const moduleNames = Object.keys(staticModules);

  return {
    pre () {
      scopes = {};
    },
    visitor: {
      Program: {
        enter: handler
      }
    }
  };

  function handler (nodePath, params) {
    if (!params.filename) throw new Error('filename required for babel-shader-import plugin');
    scopes[params.filename] = [];

    // Bail early when there is no fs import
    if (!/['"`]fs[`'"]/.test(params.file.code)) {
      return;
    }

    // This has to run before preset-env and similar plugins...
    // Need to force a full traversal.
    nodePath.traverse({
      ImportDeclaration: {
        enter: node => importHandler(node, params)
      },
      CallExpression: {
        enter: node => requireHandler(node, params)
      }
    });

    const curScopes = scopes[params.filename].filter(s => s.binding && s.binding.referenced);
    curScopes.forEach(scope => {
      const binding = scope.binding;
      binding.referencePaths.forEach(path => {
        
      });
    });
  }

  function importHandler (nodePath, params) {
    const specs = utils.getNamedImportSpecifiers(nodePath, moduleNames);
    if (!specs) return;
    if (specs.length === 0) {
      // Remove unused 'fs' imports
      nodePath.remove();
      return;
    }

    const curScopes = scopes[params.filename];
    const moduleName = nodePath.node.source.value;
    specs.forEach(spec => {
      if (t.isImportNamespaceSpecifier(spec) || t.isImportDefaultSpecifier(spec)) {
        const varName = spec.node.local.name;
        curScopes.push({
          moduleName,
          varName,
          binding: nodePath.scope.getBinding(varName)
        });
      } else if (t.isImportSpecifier(spec)) {
        const methodName = spec.node.imported.name;
        const transformMethods = Object.keys(staticModules[moduleName]);
        if (!transformMethods.includes(methodName)) return;
        const varName = spec.node.local.name;
        curScopes.push({
          moduleName,
          methodName,
          varName,
          binding: nodePath.scope.getBinding(varName)
        });
      }
    });
  }

  function requireHandler (nodePath, params) {

  }

};
