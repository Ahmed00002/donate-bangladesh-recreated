const babel = require('@babel/core');
const through = require('through2');
const { PassThrough } = require('stream');
const path = require('path');
const concat = require('concat-stream');
const duplexer = require('duplexer2');
const getModuleNotFound = require('../util/get-module-not-found');

module.exports = function createTransform (babelOpts = {}) {
  const cwd = babelOpts.cwd || process.cwd();
  return function babelify (file, transformOpts = {}) {
    const ext = path.extname(file);
    if (!babel.DEFAULT_EXTENSIONS.includes(ext)) return new PassThrough();
    if (typeof babelOpts.fileFilter === 'function' && !babelOpts.fileFilter(file, transformOpts)) {
      return new PassThrough();
    }

    const basedir = transformOpts.basedir || cwd;
    const output = through();
    const stream = duplexer(concat(code => {
      code = code.toString();
      if (typeof babelOpts.filter === 'function') {
        const valid = babelOpts.filter(code);
        if (!valid) {
          output.push(code);
          output.push(null);
          return;
        }
      }
      const settings = Object.assign({}, babelOpts, {
        // sourceRoot: basedir,
        filename: file
      });
      delete settings.filter;
      babel.transform(code, settings, (err, result) => {
        if (err) {
          const id = getModuleNotFound(err);
          if (id) {
            stream.emit('missing', { id, type: 'js', parent: file });
          } else {
            stream.emit('error', err);
          }
        } else {
          output.push(result.code);
          if (result.metadata) {
            if (result.metadata.dependencies) {
              const deps = [].concat(result.metadata.dependencies).filter(Boolean);
              deps.forEach(d => stream.emit('file', d));
            }
            if (result.metadata.missingModules) {
              const missing = [].concat(result.metadata.missingModules).filter(Boolean);
              missing.forEach(m => stream.emit('missing', m));
            }
            if (result.metadata.shaders) {
              result.metadata.shaders.forEach(shader => {
                stream.emit('glsl', {
                  filename: shader.filename,
                  code: shader.code
                });
              });
            }
          }
        }
        output.push(null);
      });
    }), output);
    return stream;
  };
};
